cat("(-2)^3:", result2, "as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result2, "unexpected.\n")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result3, "unexpected.\n")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "as expected.\n")
# Calculate (-8)^(1/3)
result3 <- re((-8)^(1/3))
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "as expected.\n")
# Calculate (-8)^(1/3)
result3 <- Re((-8)^(1/3))
cat("(-8)^(1/3):", result3, "unexpected.\n")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result3, "unexpected.\n")
# Calculate (-8)^(1/3) and obtain the correct result
result3 <- sign(-8) * abs(-8)^(1/3)
print(result3)
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result3, "unexpected.\n")
# Calculate (-8)^(1/3) and obtain the correct result
result3 <- sign(-8) * abs(-8)^(1/3)
cat("(-8)^(1/3):", result3, "finally expected...\n")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "| as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "| as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result3, "| unexpected.\n")
# Calculate (-8)^(1/3) and obtain the correct result
result3 <- sign(-8) * abs(-8)^(1/3)
cat("(-8)^(1/3):", result3, "| finally expected...\n")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "\t| as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "\t| as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result3, "\t| unexpected.\n")
# Calculate (-8)^(1/3) and obtain the correct result
result3 <- sign(-8) * abs(-8)^(1/3)
cat("(-8)^(1/3):", result3, "\t| finally expected...\n")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "\t| as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "\t| as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result3, "| unexpected.\n")
# Calculate (-8)^(1/3) and obtain the correct result
result3 <- sign(-8) * abs(-8)^(1/3)
cat("(-8)^(1/3):", result3, "\t| finally expected...\n")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "\t| as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "\t| as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result3, "| unexpected.\n")
# Calculate (-8)^(1/3) and obtain the correct result
result3 <- sign(-8) * abs(-9)^(2)
cat("(-8)^(1/3):", result3, "\t| finally expected...\n")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "\t| as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "\t| as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result3, "| unexpected.\n")
# Calculate (-8)^(1/3) and obtain the correct result
result3 <- sign(-8) * abs(-9)^(1/2)
cat("(-8)^(1/3):", result3, "\t| finally expected...\n")
source("~/School/Scientific Computation and Programming/Dervishan_Sezer-Assignment2.Rmd")
source("~/School/Scientific Computation and Programming/Dervishan_Sezer-Assignment2.Rmd")
0.3 - 0.2 == 0.1
3 - 2 == 1
(0.3 - 0.2) == 0.1
fixedpoint <- function(ftn, x0, tol = 1e-9, max.iter = 100) {
# applies the fixed-point algorithm to find x such that ftn(x) == x, we assume that ftn is a function of a single variable
# x0 is the initial guess at the fixed point algorithm terminates when successive iterations are within
# distance tol of each other (or the number of iterations exceeds max.iter)
xold <- x0 # do first iteration
xnew <- ftn(xold)
iter <- 1
cat("At iteration 1 value of x is:", xnew, "\n")
# continue iterating until stopping conditions are met
while ((abs(xnew-xold) > tol) && (iter < max.iter)) {
xold <- xnew;
xnew <- ftn(xold);
iter <- iter + 1
cat("At iteration", iter, "value of x is:", xnew, "\n")
}
# output depends on success of algorithm
if (abs(xnew-xold) > tol) {
cat("Algorithm failed to converge\n")
return(NULL)
} else {
cat("Algorithm converged\n")
return(xnew)
}
}
fixedpoint <- function(ftn, x0, tol = 1e-9, max.iter = 100) {
# applies the fixed-point algorithm to find x such that ftn(x) == x, we assume that ftn is a function of a single variable
# x0 is the initial guess at the fixed point algorithm terminates when successive iterations are within
# distance tol of each other (or the number of iterations exceeds max.iter)
xold <- x0 # do first iteration
xnew <- ftn(xold)
iter <- 1
cat("At iteration 1 value of x is:", xnew, "\n")
# continue iterating until stopping conditions are met
while ((abs(xnew-xold) > tol) && (iter < max.iter)) {
xold <- xnew;
xnew <- ftn(xold);
iter <- iter + 1
cat("At iteration", iter, "value of x is:", xnew, "\n")
}
# output depends on success of algorithm
if (abs(xnew-xold) > tol) {
cat("Algorithm failed to converge\n")
return(NULL)
} else {
cat("Algorithm converged\n")
return(xnew)
}
}
ftn3 <- function(x){
return(x+ log(x)-exp(-x))
}
fixedpoint(ftn3)
fixedpoint <- function(ftn, x0, tol = 1e-9, max.iter = 100) {
# applies the fixed-point algorithm to find x such that ftn(x) == x, we assume that ftn is a function of a single variable
# x0 is the initial guess at the fixed point algorithm terminates when successive iterations are within
# distance tol of each other (or the number of iterations exceeds max.iter)
xold <- x0 # do first iteration
xnew <- ftn(xold)
iter <- 1
cat("At iteration 1 value of x is:", xnew, "\n")
# continue iterating until stopping conditions are met
while ((abs(xnew-xold) > tol) && (iter < max.iter)) {
xold <- xnew;
xnew <- ftn(xold);
iter <- iter + 1
cat("At iteration", iter, "value of x is:", xnew, "\n")
}
# output depends on success of algorithm
if (abs(xnew-xold) > tol) {
cat("Algorithm failed to converge\n")
return(NULL)
} else {
cat("Algorithm converged\n")
return(xnew)
}
}
ftn3 <- function(x){
return(x+ log(x)-exp(-x))
}
fixedpoint(ftn3, 2)
library(broom)
library(ggplot2)
library(modelr)
library(tidyverse)
install.packages(c("broom", "tidyverse", "ggplot2", "modelr"))
install.packages("shiny")
library(shiny); runApp('School/Scientific Computation and Programming/Assignments/RootDetective/UI.R')
runApp('School/Scientific Computation and Programming/Assignments/RootDetective/UI.R')
runApp('School/Scientific Computation and Programming/Assignments/RootDetective/UI.R')
runApp('School/Scientific Computation and Programming/Assignments/RootDetective/UI.R')
runApp('School/Scientific Computation and Programming/Assignments/RootDetective/UI.R')
# Probability of X to be less than 0
pnorm(0)
# Quantile to get 50% of the distribution
qnorm(0.5)
# Density function value at x = 0
dnorm(0)
# Let's confirm
(1/sqrt(2*pi))
z <- rnorm(10000)
# build the density function
phi <- function(x){
return(exp(-x^2/2)/sqrt(2*pi))
}
# To create a plot: discretize the domain
x <- seq(from = -5, to = 5, by = 0.1)
hist(z, breaks = seq(-5,5,0.2))
hist(z, breaks = seq(-5,5,0.2))
hist(z, breaks = seq(-5,5,0.2))
plot(x,phi(x),type = "l")
hist(z, breaks = seq(-5,5,0.2), freq = FALSE)
plot(x,phi(x))
hist(z, breaks = seq(-5,5,0.2), freq = FALSE)
lines(x,phi(x))
# set a random seed
set.seed(217)
# first variable
z1 <- rnorm(1000, mean = 1, sd = 1)
# second variable
z2 <- rnorm(1000, mean = 1, sd = 2)
# new variable
z3 <- z1 + z2
# histogram of new variable
hist(z3, breaks = seq(-10, 14, 0.2), freq = FALSE)
# # N(2, 5) density
phi_2 <- function(x){
return(exp(-(x-2)^2/10)/sqrt(10*pi))
}
# domain discretization
x <- seq(-10,14,0.1)
# plot
lines(x, phi_2(x), col = "blue")
# Number of simulation
n <- 1e4L
# Number of flips
nFlips <- 100L
# How many in a row for a success
comparison <- 10L
# Keep track of "successes"
num_yes <- 0L
# We let 1 represent "heads" and 0 "not heads"
for(i in 1:n){
num_yes <- num_yes + max(rle(rbinom(nFlips, 1, prob = 0.5))$lengths) >= comparison
}
# Estimated probability
num_yes / n
# Number of simulation
n <- 1e4L
# Number of flips
nFlips <- 100L
# How many in a row for a success
comparison <- 10L
# Keep track of "successes"
num_yes <- 0L
# We let 1 represent "heads" and 0 "not heads"
for(i in 1:n){
num_yes <- num_yes + max(rle(rbinom(nFlips, 1, prob = 0.5))$Lengths) >= comparison
}
# Number of simulation
n <- 1e4L
# Number of flips
nFlips <- 100L
# How many in a row for a success
comparison <- 10L
# Keep track of "successes"
num_yes <- 0L
# We let 1 represent "heads" and 0 "not heads"
for(i in 1:n){
num_yes <- num_yes + max(rle(rbinom(nFlips, 1, prob = 0.5))$lengths) >= comparison
}
# Estimated probability
num_yes / n
# Number of simulation
n <- 1e4L
# Number of flips
nFlips <- 100L
# How many in a row for a success
comparison <- 10L
# Keep track of "successes"
num_yes <- 0L
# We let 1 represent "heads" and 0 "not heads"
for(i in 1:n){
num_yes <- num_yes + (max(rle(rbinom(nFlips, 1, prob = 0.5))$lengths) >= comparison)
}
# Estimated probability
num_yes / n
findRoot <- function(f, a, b, num = 10, eps = 1e-05) {
h <- abs(b - a) / num
i <- 0
j <- 0
a1 <- b1 <- 0
while (i <= num) {
a1 <- a + i * h
b1 <- a1 + h
if (f(a1) == 0) {
cat("Root found at:", a1, "\nValue at root:", f(a1), "\n")
} else if (f(b1) == 0) {
cat("Root found at:", b1, "\nValue at root:", f(b1), "\n")
} else if (f(a1) * f(b1) < 0) {
repeat {
if (abs(b1 - a1) < eps) break
x <- (a1 + b1) / 2
if (f(a1) * f(x) < 0) {
b1 <- x
} else {
a1 <- x
}
}
cat("Iteration:", j + 1, "\nApproximate root:", (a1 + b1) / 2, "\nValue at root:", f((a1 + b1) / 2), "\n")
j <- j + 1
}
i <- i + 1
}
if (j == 0) {
cat("Finding root failed\n")
} else {
cat("Finding root successful\n")
}
}
findRoot(x^2-4,1,2)
f <- function(x){
return(x^2-4)
}
findRoot(f,1,2)
f <- function(x){
return(x^2-4)
}
findRoot(f,-10,12)
f <- function(x){
return(x^2-4)
}
findRoot(f,-2,2)
f <- function(x){
return(x^2-4)
}
findRoot(f,-2,3)
f <- function(x){
return(x^2-4)
}
findRoot(f,-4,3)
secant <- function(f, x0, x1, tol = 1e-9, n = 500) {
if (is.function(f) == FALSE) {
stop('f is not a function')
}
for (i in 1:n) {
x2 <- x1 - f(x1) / ((f(x1) - f(x0)) / (x1 - x0)) # Calculate the new x value
if (abs(x2 - x1) < tol) { # If the difference between the new value and the previous value is small enough, end iteration and output root.
return(x2)
}
# If the root was not determined in the previous iteration, reassign the values and proceed to next iteration.
x0 <- x1
x1 <- x2
}
}
secant(f,-4,3)
shiny::runApp('C:/Users/VICTUS/Desktop/RootDetective')
runApp('C:/Users/VICTUS/AppData/Local/Microsoft/Windows/INetCache/IE/TB323S2U/app[1].R')
runApp('C:/Users/VICTUS/Desktop/RootDetective')
brentDekker(f, -10, 10)
install.packages("pracma")
library(pracma)
brentDekker(f, -10, 10)
brent(f, 0,1)
brent(f, 0, 5)
brenta <- function(f, lower, upper, tol = .Machine$double.eps^0.5, max.iter = 100) {
if (lower > upper) {
stop("upper must be greater than lower")
}
a <- lower
b <- upper
fa <- f(a)
fb <- f(b)
if (fa * fb > 0) {
stop("Function must have opposite signs at the endpoints.")
}
if (abs(fa) < abs(fb)) {
a <- upper
b <- lower
temp <- fa
fa <- fb
fb <- temp
}
c <- a
fc <- fa
mflag <- TRUE
for (iter in 1:max.iter) {
if (fa != fc && fb != fc) {
# Inverse quadratic interpolation
s <- a * fb * fc / ((fa - fb) * (fa - fc)) +
b * fa * fc / ((fb - fa) * (fb - fc)) +
c * fa * fb / ((fc - fa) * (fc - fb))
} else {
# Secant method
s <- b - fb * (b - a) / (fb - fa)
}
tmp2 <- (3 * a + b) / 4
if (!((s > tmp2 && s < b) || (s < tmp2 && s > b)) ||
(mflag && abs(s - b) >= abs(b - c) / 2) ||
(!mflag && abs(s - b) >= abs(c - d) / 2) ||
(mflag && abs(b - c) < tol) ||
(!mflag && abs(c - d) < tol)) {
s <- (a + b) / 2
mflag <- TRUE
} else {
mflag <- FALSE
}
fs <- f(s)
d <- c
c <- b
fc <- fb
if (fa * fs < 0) {
b <- s
fb <- fs
} else {
a <- s
fa <- fs
}
if (abs(fa) < abs(fb)) {
temp <- a
a <- b
b <- temp
temp <- fa
fa <- fb
fb <- temp
}
if (abs(b - a) < tol) {
return(list(root = b, f.root = fb, iter = iter))
}
}
stop("Maximum number of iterations reached")
}
# Example usage:
# Define a function, for example, f(x) = x^2 - 3
f <- function(x) x^2 - 3
# Find the root between 1 and 2
result <- brent(f, 1, 2)
print(result)
brenta(f,0,5)
brent(f,0,5)
brent(f,0,5)
brenta(f,0,5)
brent(f,0,5)
brenta(f,0,5)
brent(f,0,5)
brent(f, 0, 5)
brenta(f,0,5)
brent(f,0,5)
brent(f, 0, 5)
fixedpoint <- function (ftn, x0, tol = 1e-09, max.iter = 100)
{
xold <- x0
xnew <- ftn(xold)
iter <- 1
cat("At iteration 1 value of x is:", xnew, "\n")
while ((abs(xnew - xold) > tol) && (iter < max.iter)) {
xold <- xnew
xnew <- ftn(xold)
iter <- iter + 1
cat("At iteration", iter, "value of x is:", xnew, "\n")
}
if (abs(xnew - xold) > tol) {
cat("Algorithm failed to converge\n")
return(NULL)
}
else {
cat("Algorithm converged\n")
return(xnew)
}
}
shiny::runApp('C:/Users/VICTUS/Desktop/RootDetective')
library(learnr)
question("Question 1: What is the output of (check below code)",
answer("20"),
answer("maybe"),
answer("definitely not", correct = TRUE),
answer("FALSE")
)
install.packages("htmltools")
install.packages("htmltools")
install.packages("htmltools")
install.packages("htmltools")
install.packages("htmltools")
unlink("C:/Users/VICTUS/AppData/Local/Microsoft/Windows/INetCache/IE/9RBXZ2SJ/QuizReview[1]_cache", recursive = TRUE)
library(learnr)
ınstall.package(learner)
ınstall.package(learnr)
ınstall.package("learnr")
ınstall.packages("learnr")
install.packages("learnr")
install.packages("shıny")
shiny::runApp('C:/Users/VICTUS/Desktop/RootDetective')
runApp('C:/Users/VICTUS/Desktop/RootDetective')
shiny::runApp('C:/Users/VICTUS/Desktop/RootDetective')
