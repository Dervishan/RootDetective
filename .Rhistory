rowMeans(test_data)
my_row_means(test_data)
my_row_means <- function(x){
means <- c()
for (rowNum in nrow(x)) {
append(means,mean(x[rowNum, ])
}
my_row_means <- function(x){
means <- c()
for (rowNum in nrow(x)) {
append(means, mean(x[rowNum, ]))
}
return(means)
}
rowMeans(test_data)
my_row_means(test_data)
my_row_means <- function(x){
means <- c()
for (rowNum in nrow(x)) {
meanOfTheRows <- mean(x[rowNum, ])
append(means, meanOfTheRows)
}
return(means)
}
rowMeans(test_data)
my_row_means(test_data)
my_row_means <- function(x){
means <- c()
for (rowNum in nrow(x)) {
meanOfTheRows <- mean(x[rowNum, ])
append(means, meanOfTheRows)
}
return(means)
}
means
View(my_row_means)
View(my_row_means)
my_row_means <- function(x){
means <- c()
for (rowNum in nrow(x)) {
meanOfTheRows <- mean(x[rowNum, ])
append(means, meanOfTheRows)
}
return(means)
}
rowMeans(test_data)
my_row_means(test_data)
my_row_means <- function(x){
means <- c()
for (rowNum in 1:nrow(x)) {
meanOfTheRows <- mean(x[rowNum, ])
append(means, meanOfTheRows)
}
return(means)
}
rowMeans(test_data)
my_row_means(test_data)
my_row_means <- function(x){
means <- c()
for (rowNum in 1:nrow(x)) {
meanOfTheRow <- mean(x[rowNum, ])
means <- append(means, meanOfTheRow)
}
return(means)
}
rowMeans(test_data)
my_row_means(test_data)
distance_between_planes <- function(point_on_plane, other_plane) {
distance <-
abs(sum(point_on_plane * other_plane[1:3]) + other_plane[4])  / sqrt(sum(other_plane[1:3] ^ 2))
return(distance)
}
distance_between_planes(c(0, 0, 1), c(3, 6, -3, -3))
distBetweenParallelPlanes <- function(point, plane) {
distance <-
abs(sum(point * plane[1:3]) + plane[4])  / sqrt(sum(plane[1:3] ^ 2))
return(distance)
}
distBetweenParallelPlanes(c(0, 0, 1), c(3, 6, -3, -3))
distBetweenParallelPlanes <- function(point, plane) {
distance <-
abs(sum(point * plane[1:3]) + plane[4])  / sqrt(sum(plane[1:3] ^ 2))
return(distance)
}
distBetweenParallelPlanes(c(-1, 0, 0), c(3, 6, -3, -3))
# Calculate 8^(1/3)
result1 <- 8^(1/3)
print(result1)
# Calculate (-2)^3
result2 <- (-2)^3
print(result2)
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
c("Rows that contain exactly two occurences of 4 are;", result3)
# Calculate 8^(1/3)
result1 <- 8^(1/3)
print(result1)
# Calculate (-2)^3
result2 <- (-2)^3
print(result2)
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
c("Rows that contain exactly two occurences of 4 are;", as.double(result3))
# Calculate 8^(1/3)
result1 <- 8^(1/3)
print(result1)
# Calculate (-2)^3
result2 <- (-2)^3
print(result2)
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
c("Rows that contain exactly two occurences of 4 are;", as.character(result3))
# Calculate 8^(1/3)
result1 <- 8^(1/3)
print(result1)
# Calculate (-2)^3
result2 <- (-2)^3
print(result2)
# Calculate (-8)^(1/3)
(-8)^(1/3)
# Calculate 8^(1/3)
result1 <- 8^(1/3)
print(result1)
# Calculate (-2)^3
result2 <- (-2)^3
print(result2)
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
print(result3)
# Calculate 8^(1/3)
result1 <- 8^(1/3)
print(result1)
# Calculate (-2)^3
result2 <- (-2)^3
print(result2)
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
print(result3)
# Calculate 8^(1/3)
result1 <- 8^(1/3)
print(result1, "as expected")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
print(result1 +"as expected")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat(result1 +"as expected")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat(result1 ,"as expected")
# Calculate (-2)^3
result2 <- (-2)^3
print(result2)
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
print(result3)
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat(result1, "as expected")
# Calculate (-2)^3
result2 <- (-2)^3
cat(result2, "as expected")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
print(result3)
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat(result1, "as expected\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat(result2, "as expected\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
print(result3)
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "as expected\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat(result2, "as expected\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
print(result3)
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
print(result3)
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result2, "as expected.\n")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result2, "unexpected.\n")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result3, "unexpected.\n")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "as expected.\n")
# Calculate (-8)^(1/3)
result3 <- re((-8)^(1/3))
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "as expected.\n")
# Calculate (-8)^(1/3)
result3 <- Re((-8)^(1/3))
cat("(-8)^(1/3):", result3, "unexpected.\n")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result3, "unexpected.\n")
# Calculate (-8)^(1/3) and obtain the correct result
result3 <- sign(-8) * abs(-8)^(1/3)
print(result3)
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result3, "unexpected.\n")
# Calculate (-8)^(1/3) and obtain the correct result
result3 <- sign(-8) * abs(-8)^(1/3)
cat("(-8)^(1/3):", result3, "finally expected...\n")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "| as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "| as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result3, "| unexpected.\n")
# Calculate (-8)^(1/3) and obtain the correct result
result3 <- sign(-8) * abs(-8)^(1/3)
cat("(-8)^(1/3):", result3, "| finally expected...\n")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "\t| as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "\t| as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result3, "\t| unexpected.\n")
# Calculate (-8)^(1/3) and obtain the correct result
result3 <- sign(-8) * abs(-8)^(1/3)
cat("(-8)^(1/3):", result3, "\t| finally expected...\n")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "\t| as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "\t| as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result3, "| unexpected.\n")
# Calculate (-8)^(1/3) and obtain the correct result
result3 <- sign(-8) * abs(-8)^(1/3)
cat("(-8)^(1/3):", result3, "\t| finally expected...\n")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "\t| as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "\t| as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result3, "| unexpected.\n")
# Calculate (-8)^(1/3) and obtain the correct result
result3 <- sign(-8) * abs(-9)^(2)
cat("(-8)^(1/3):", result3, "\t| finally expected...\n")
# Calculate 8^(1/3)
result1 <- 8^(1/3)
cat("8^(1/3):", result1, "\t| as expected.\n")
# Calculate (-2)^3
result2 <- (-2)^3
cat("(-2)^3:", result2, "\t| as expected.\n")
# Calculate (-8)^(1/3)
result3 <- (-8)^(1/3)
cat("(-8)^(1/3):", result3, "| unexpected.\n")
# Calculate (-8)^(1/3) and obtain the correct result
result3 <- sign(-8) * abs(-9)^(1/2)
cat("(-8)^(1/3):", result3, "\t| finally expected...\n")
source("~/School/Scientific Computation and Programming/Dervishan_Sezer-Assignment2.Rmd")
source("~/School/Scientific Computation and Programming/Dervishan_Sezer-Assignment2.Rmd")
0.3 - 0.2 == 0.1
3 - 2 == 1
(0.3 - 0.2) == 0.1
fixedpoint <- function(ftn, x0, tol = 1e-9, max.iter = 100) {
# applies the fixed-point algorithm to find x such that ftn(x) == x, we assume that ftn is a function of a single variable
# x0 is the initial guess at the fixed point algorithm terminates when successive iterations are within
# distance tol of each other (or the number of iterations exceeds max.iter)
xold <- x0 # do first iteration
xnew <- ftn(xold)
iter <- 1
cat("At iteration 1 value of x is:", xnew, "\n")
# continue iterating until stopping conditions are met
while ((abs(xnew-xold) > tol) && (iter < max.iter)) {
xold <- xnew;
xnew <- ftn(xold);
iter <- iter + 1
cat("At iteration", iter, "value of x is:", xnew, "\n")
}
# output depends on success of algorithm
if (abs(xnew-xold) > tol) {
cat("Algorithm failed to converge\n")
return(NULL)
} else {
cat("Algorithm converged\n")
return(xnew)
}
}
fixedpoint <- function(ftn, x0, tol = 1e-9, max.iter = 100) {
# applies the fixed-point algorithm to find x such that ftn(x) == x, we assume that ftn is a function of a single variable
# x0 is the initial guess at the fixed point algorithm terminates when successive iterations are within
# distance tol of each other (or the number of iterations exceeds max.iter)
xold <- x0 # do first iteration
xnew <- ftn(xold)
iter <- 1
cat("At iteration 1 value of x is:", xnew, "\n")
# continue iterating until stopping conditions are met
while ((abs(xnew-xold) > tol) && (iter < max.iter)) {
xold <- xnew;
xnew <- ftn(xold);
iter <- iter + 1
cat("At iteration", iter, "value of x is:", xnew, "\n")
}
# output depends on success of algorithm
if (abs(xnew-xold) > tol) {
cat("Algorithm failed to converge\n")
return(NULL)
} else {
cat("Algorithm converged\n")
return(xnew)
}
}
ftn3 <- function(x){
return(x+ log(x)-exp(-x))
}
fixedpoint(ftn3)
fixedpoint <- function(ftn, x0, tol = 1e-9, max.iter = 100) {
# applies the fixed-point algorithm to find x such that ftn(x) == x, we assume that ftn is a function of a single variable
# x0 is the initial guess at the fixed point algorithm terminates when successive iterations are within
# distance tol of each other (or the number of iterations exceeds max.iter)
xold <- x0 # do first iteration
xnew <- ftn(xold)
iter <- 1
cat("At iteration 1 value of x is:", xnew, "\n")
# continue iterating until stopping conditions are met
while ((abs(xnew-xold) > tol) && (iter < max.iter)) {
xold <- xnew;
xnew <- ftn(xold);
iter <- iter + 1
cat("At iteration", iter, "value of x is:", xnew, "\n")
}
# output depends on success of algorithm
if (abs(xnew-xold) > tol) {
cat("Algorithm failed to converge\n")
return(NULL)
} else {
cat("Algorithm converged\n")
return(xnew)
}
}
ftn3 <- function(x){
return(x+ log(x)-exp(-x))
}
fixedpoint(ftn3, 2)
library(broom)
library(ggplot2)
library(modelr)
library(tidyverse)
install.packages(c("broom", "tidyverse", "ggplot2", "modelr"))
install.packages("shiny")
library(shiny); runApp('School/Scientific Computation and Programming/Assignments/RootDetective/UI.R')
runApp('School/Scientific Computation and Programming/Assignments/RootDetective/UI.R')
runApp('School/Scientific Computation and Programming/Assignments/RootDetective/UI.R')
runApp('School/Scientific Computation and Programming/Assignments/RootDetective/UI.R')
runApp('School/Scientific Computation and Programming/Assignments/RootDetective/UI.R')
# Probability of X to be less than 0
pnorm(0)
# Quantile to get 50% of the distribution
qnorm(0.5)
# Density function value at x = 0
dnorm(0)
# Let's confirm
(1/sqrt(2*pi))
z <- rnorm(10000)
# build the density function
phi <- function(x){
return(exp(-x^2/2)/sqrt(2*pi))
}
# To create a plot: discretize the domain
x <- seq(from = -5, to = 5, by = 0.1)
hist(z, breaks = seq(-5,5,0.2))
hist(z, breaks = seq(-5,5,0.2))
hist(z, breaks = seq(-5,5,0.2))
plot(x,phi(x),type = "l")
hist(z, breaks = seq(-5,5,0.2), freq = FALSE)
plot(x,phi(x))
hist(z, breaks = seq(-5,5,0.2), freq = FALSE)
lines(x,phi(x))
# set a random seed
set.seed(217)
# first variable
z1 <- rnorm(1000, mean = 1, sd = 1)
# second variable
z2 <- rnorm(1000, mean = 1, sd = 2)
# new variable
z3 <- z1 + z2
# histogram of new variable
hist(z3, breaks = seq(-10, 14, 0.2), freq = FALSE)
# # N(2, 5) density
phi_2 <- function(x){
return(exp(-(x-2)^2/10)/sqrt(10*pi))
}
# domain discretization
x <- seq(-10,14,0.1)
# plot
lines(x, phi_2(x), col = "blue")
# Number of simulation
n <- 1e4L
# Number of flips
nFlips <- 100L
# How many in a row for a success
comparison <- 10L
# Keep track of "successes"
num_yes <- 0L
# We let 1 represent "heads" and 0 "not heads"
for(i in 1:n){
num_yes <- num_yes + max(rle(rbinom(nFlips, 1, prob = 0.5))$lengths) >= comparison
}
# Estimated probability
num_yes / n
# Number of simulation
n <- 1e4L
# Number of flips
nFlips <- 100L
# How many in a row for a success
comparison <- 10L
# Keep track of "successes"
num_yes <- 0L
# We let 1 represent "heads" and 0 "not heads"
for(i in 1:n){
num_yes <- num_yes + max(rle(rbinom(nFlips, 1, prob = 0.5))$Lengths) >= comparison
}
# Number of simulation
n <- 1e4L
# Number of flips
nFlips <- 100L
# How many in a row for a success
comparison <- 10L
# Keep track of "successes"
num_yes <- 0L
# We let 1 represent "heads" and 0 "not heads"
for(i in 1:n){
num_yes <- num_yes + max(rle(rbinom(nFlips, 1, prob = 0.5))$lengths) >= comparison
}
# Estimated probability
num_yes / n
# Number of simulation
n <- 1e4L
# Number of flips
nFlips <- 100L
# How many in a row for a success
comparison <- 10L
# Keep track of "successes"
num_yes <- 0L
# We let 1 represent "heads" and 0 "not heads"
for(i in 1:n){
num_yes <- num_yes + (max(rle(rbinom(nFlips, 1, prob = 0.5))$lengths) >= comparison)
}
# Estimated probability
num_yes / n
shiny::runApp('C:/Users/VICTUS/Desktop/RootDetective')
